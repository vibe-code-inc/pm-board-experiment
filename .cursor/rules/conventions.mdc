---
description: Required project conventions
globs:
alwaysApply: true
---
// Project Conventions
// This rule file defines coding conventions for the project

// ====================================================
// FILE AND DIRECTORY NAMING CONVENTIONS
// ====================================================

// Use snake_case for all file and directory names
// Examples:
// CORRECT:
//   ✓ project_board.tsx
//   ✓ task_list.tsx
//   ✓ utils.ts
//   ✓ task_card/
//   ✓ design_kit/
// INCORRECT:
//   ✗ ProjectBoard.tsx
//   ✗ taskList.tsx
//   ✗ TaskList.tsx
//   ✗ task-card/
//   ✗ DesignKit/

// ====================================================
// IMPORT CONVENTIONS
// ====================================================

// Use absolute imports with @/ prefix
// Examples:
// CORRECT:
//   ✓ import { Button } from '@/ui/base/design_kit/button/button';
//   ✓ import { Task } from '@/types';
//   ✓ import { cn } from '@/lib/utils';
// INCORRECT:
//   ✗ import { Button } from '../../ui/base/design_kit/button/button';
//   ✗ import { Task } from '../types';
//   ✗ import { cn } from './utils';

// ====================================================
// PROJECT STRUCTURE CONVENTIONS
// ====================================================

/*
Project Structure:

/src
  /features - Feature-specific modules that wire components together
    /project_board
    /task_management
  /ui - UI components
    /base - Primitive UI components
      /design_kit - Basic design system components
        /button
        /input
        /select
        /textarea
    /features - Complex reusable UI components
      /task_card
      /task_modal
  /lib - Utility functions and helpers
  /types.ts - Type definitions
  /app.tsx - Main application
  /main.tsx - Entry point
*/

// ====================================================
// CONSTANTS AND THEME CONVENTIONS
// ====================================================

// Extract hardcoded values into constants files
// Examples:

// 1. IDs should be in a constants file:
// CORRECT:
//   ✓ import { PROJECT_ID, TASK_IDS } from '@/constants/ids';
//   ✓ id: PROJECT_ID.WEBSITE_REDESIGN
// INCORRECT:
//   ✗ id: '1'
//   ✗ id: 'website-redesign'

// 2. Colors should use a theme configuration:
// CORRECT:
//   ✓ import { COLORS } from '@/ui/theme/colors';
//   ✓ const priorityColors = COLORS.priority;
// INCORRECT:
//   ✗ low: 'bg-blue-100 text-blue-800',
//   ✗ const highPriorityColor = '#FF0000';

// 3. Component styles should be extracted:
// CORRECT:
//   ✓ import { BUTTON_STYLES } from '@/ui/base/design_kit/button/button_styles';
//   ✓ const { base, variants, sizes } = BUTTON_STYLES;
// INCORRECT:
//   ✗ const baseStyles = 'rounded-md font-medium...';
//   ✗ <button className="px-4 py-2 bg-blue-500 text-white rounded">Click me</button>

// ====================================================
// TYPE CONVENTIONS
// ====================================================

// Use explicit type annotations
// Examples:
// CORRECT:
//   ✓ const [project, setProject] = useState<Project>(initialProject);
//   ✓ const handleTaskUpdate = (taskId: string, newStatus: Task['status']) => {...}
// INCORRECT:
//   ✗ const [project, setProject] = useState(initialProject);
//   ✗ const handleTaskUpdate = (taskId, newStatus) => {...}

// ====================================================
// COMPONENT CONVENTIONS
// ====================================================

// 1. Use function component syntax with React.FC and explicit props interface
// Example:
/*
CORRECT:
interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'ghost';
  size?: 'sm' | 'md' | 'lg';
}

export const Button: React.FC<ButtonProps> = ({
  children,
  className,
  variant = 'primary',
  size = 'md',
  ...props
}) => {
  // Component implementation
};

INCORRECT:
export const Button = (props) => {
  const { children, className, variant = 'primary', size = 'md', ...rest } = props;
  // Component implementation
};
*/

// 2. Keep components focused and extract complex logic
// Example:
/*
CORRECT:
// Separate hooks for complex logic
const useTaskManagement = (initialTasks: Task[]) => {
  const [tasks, setTasks] = useState<Task[]>(initialTasks);

  const updateTaskStatus = (taskId: string, status: Task['status']) => {
    setTasks(prev =>
      prev.map(task => task.id === taskId ? {...task, status} : task)
    );
  };

  return { tasks, updateTaskStatus };
};

// Use in component
export const TaskBoard: React.FC<TaskBoardProps> = ({ initialTasks }) => {
  const { tasks, updateTaskStatus } = useTaskManagement(initialTasks);

  // Component rendering logic
};

INCORRECT:
export const TaskBoard: React.FC<TaskBoardProps> = ({ initialTasks }) => {
  const [tasks, setTasks] = useState<Task[]>(initialTasks);

  // Complex logic mixed with component
  const updateTaskStatus = (taskId: string, status: Task['status']) => {
    setTasks(prev =>
      prev.map(task => task.id === taskId ? {...task, status} : task)
    );
  };

  // More complex functions...

  // Component rendering logic
};
*/

// ====================================================
// STATE MANAGEMENT CONVENTIONS
// ====================================================

// 1. Use useState for component-level state
// Example:
/*
CORRECT:
const [isEditing, setIsEditing] = useState(false);
const [task, setTask] = useState<Task>(initialTask);

INCORRECT:
let isEditing = false;
let task = initialTask;
const toggleEditing = () => { isEditing = !isEditing; };
*/

// 2. Use callbacks for state updates
// Example:
/*
CORRECT:
const handleTaskUpdate = (updatedTask: Task) => {
  setTask(updatedTask);
};

const handleStatusChange = (status: Task['status']) => {
  onStatusChange(status);
};

INCORRECT:
const handleTaskUpdate = () => {
  task.status = 'completed'; // Mutating state directly
  setTask(task);
};
*/

// ====================================================
// EVENT HANDLER CONVENTIONS
// ====================================================

// 1. Prefix event handlers with 'handle'
// Example:
/*
CORRECT:
const handleSubmit = (e: React.FormEvent) => {
  e.preventDefault();
  onSave(task);
};

const handleDragStart = (e: React.DragEvent) => {
  e.dataTransfer.setData('taskId', task.id);
};

INCORRECT:
const submitForm = (e: React.FormEvent) => {
  e.preventDefault();
  onSave(task);
};

const dragStart = (e: React.DragEvent) => {
  e.dataTransfer.setData('taskId', task.id);
};
*/

// 2. Use explicit event types
// Example:
/*
CORRECT:
const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
  onChange({ ...task, title: e.target.value });
};

INCORRECT:
const handleChange = (e) => {
  onChange({ ...task, title: e.target.value });
};
*/

// ====================================================
// CSS & STYLING CONVENTIONS
// ====================================================

// 1. Use className with Tailwind CSS utilities
// Example:
/*
CORRECT:
<div className="p-4 rounded-lg shadow-sm bg-gray-100 transition-all hover:shadow-md">
  <h3 className="font-semibold text-gray-800">{task.title}</h3>
</div>

INCORRECT:
<div style={{ padding: '1rem', borderRadius: '0.5rem', backgroundColor: '#f3f4f6' }}>
  <h3 style={{ fontWeight: 600, color: '#1f2937' }}>{task.title}</h3>
</div>
*/

// 2. Use cn utility for conditional classes
// Example:
/*
CORRECT:
import { cn } from '@/lib/utils';

<button
  className={cn(
    baseStyles,
    variants[variant],
    sizes[size],
    className
  )}
  {...props}
>
  {children}
</button>

INCORRECT:
<button
  className={`${baseStyles} ${variants[variant]} ${sizes[size]} ${className}`}
  {...props}
>
  {children}
</button>
*/

// ====================================================
// DESTRUCTURING CONVENTIONS
// ====================================================

// Use destructuring for props
// Example:
/*
CORRECT:
export const TaskCard: React.FC<TaskCardProps> = ({
  task: initialTask,
  onStatusChange,
  onEdit,
}) => {
  // Component implementation
};

INCORRECT:
export const TaskCard: React.FC<TaskCardProps> = (props) => {
  const initialTask = props.task;
  const onStatusChange = props.onStatusChange;
  const onEdit = props.onEdit;
  // Component implementation
};
*/
