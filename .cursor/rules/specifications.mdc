---
description: Required rules for building features and creating, updating, and handling any code changes
globs: "*.{ts,tsx,js,jsx,md}"
alwaysApply: true
---

<rule>
  <meta>
    <title>Specification Development</title>
    <description>Enforces development practices centered around specifications to ensure requirements are properly documented and implemented</description>
    <created-at utc-timestamp="1712678400">April 9, 2024, 10:00 AM EDT</created-at>
    <last-updated-at utc-timestamp="1712678400">April 9, 2024, 10:00 AM EDT</last-updated-at>
    <applies-to>
      <file-matcher glob="*.{ts,tsx}">TypeScript and React files</file-matcher>
      <file-matcher glob="*.{js,jsx}">JavaScript and React files</file-matcher>
      <file-matcher glob="*.specs.md">Specification files</file-matcher>
      <file-matcher glob="*.package_specs.md">Package specification files</file-matcher>
      <action-matcher action="code-modification">Triggered when modifying code</action-matcher>
    </applies-to>
  </meta>
  <requirements>
    <non-negotiable priority="critical">
      <description>RULE HIERARCHY: There is a strict hierarchy of rules that must be followed at all times: @conventions.mdc, @engineering_and_design_rules.mdc, then @specifications.mdc.</description>
      <examples>
        <example title="Rule Hierarchy Compliance">
          <correct-example title="Following rule hierarchy" conditions="When rules contradict" expected-result="Higher priority rule is followed" correctness-criteria="Prioritizes rules in correct order"><![CDATA[// When @conventions.mdc requires snake_case file names
// and specification mentions camelCase:

// CORRECT ACTION:
// 1. Follow @conventions.mdc (higher priority)
// 2. Use snake_case for the file name
// 3. Update specification to align with @conventions.mdc]]></correct-example>
          <incorrect-example title="Ignoring rule hierarchy" conditions="When rules contradict" expected-result="Higher priority rule is followed" incorrectness-criteria="Follows lower priority rule"><![CDATA[// When @conventions.mdc requires snake_case file names
// and specification mentions camelCase:

// INCORRECT ACTION:
// 1. Follow the specification (lower priority)
// 2. Use camelCase for the file name
// 3. Leave the contradiction unresolved]]></incorrect-example>
        </example>
      </examples>
    </non-negotiable>
    <non-negotiable priority="critical">
      <description>When tasked with modifying code, ALWAYS generate and print a specification first.</description>
      <examples>
        <example title="Specification-First Development">
          <correct-example title="Creating specification before code" conditions="Adding a new feature" expected-result="Specification precedes implementation" correctness-criteria="Creates specification first"><![CDATA[// CORRECT WORKFLOW:
// 1. Create task_card.specs.md with complete requirements
// 2. Only after completing the specification, implement code in task_card.tsx
// 3. Ensure implementation matches the specification requirements]]></correct-example>
          <incorrect-example title="Coding without specification" conditions="Adding a new feature" expected-result="Specification precedes implementation" incorrectness-criteria="Begins coding without a specification"><![CDATA[// INCORRECT WORKFLOW:
// 1. Start coding in task_card.tsx without a specification
// 2. Create specification after code is complete or not at all
// 3. Implementation may not have clear requirements]]></incorrect-example>
        </example>
      </examples>
    </non-negotiable>
    <requirement priority="high">
      <description>Specifications must include: Technical requirements, Product requirements, Behavioral expectations, Interfaces, and Files/modules to be changed.</description>
      <examples>
        <example title="Complete Specification Content">
          <correct-example title="Comprehensive specification" conditions="Creating a specification" expected-result="Complete specification with all required sections" correctness-criteria="Includes all required content sections"><![CDATA[# Task Card Component Specification

## Overview
The Task Card component displays individual task information and supports drag-and-drop functionality.

## Product Requirements
- Display task title, description, priority, and due date
- Support drag-and-drop between columns
- Show visual feedback during drag operations

## Technical Requirements
- Use React DnD library for drag-and-drop
- Implement edge scrolling when dragging near viewport boundaries
- Optimize rendering to prevent performance issues

## Behavioral Expectations
- Cards should snap to valid drop zones
- Invalid drop zones should reject cards with visual feedback
- Dragging should start after 150ms of mouse down

## Interfaces
type TaskCardProps = {
  task: Task;
  onStatusChange: (taskId: string, status: Task['status']) => void;
}

## Files/Modules to be Changed
- src/features/task_board/task_card.tsx - Create new component
- src/features/task_board/task_board.tsx - Import and use TaskCard]]></correct-example>
          <incorrect-example title="Incomplete specification" conditions="Creating a specification" expected-result="Complete specification with all required sections" incorrectness-criteria="Missing critical sections"><![CDATA[# Task Card Component Specification

## Overview
The Task Card component displays tasks.

## Technical Requirements
- Make it draggable

## Interfaces
type TaskCardProps = {
  task: Task;
}]]></incorrect-example>
        </example>
      </examples>
    </requirement>
    <requirement priority="high">
      <description>Follow this discovery sequence for every code modification: Check package_specs.md in the target folder first, then file_name.specs.md in the same folder, and only proceed after understanding all specifications.</description>
      <examples>
        <example title="Specification Discovery Process">
          <correct-example title="Proper discovery sequence" conditions="Before modifying code" expected-result="Complete understanding of all applicable specifications" correctness-criteria="Follows correct discovery sequence"><![CDATA[// When modifying src/features/task_board/task_list.tsx:
// CORRECT PROCESS:
// 1. First check: src/features/task_board/task_board.package_specs.md
// 2. Then check: src/features/task_board/task_list.specs.md
// 3. Only then modify src/features/task_board/task_list.tsx]]></correct-example>
          <incorrect-example title="Skipping discovery steps" conditions="Before modifying code" expected-result="Complete understanding of all applicable specifications" incorrectness-criteria="Ignores discovery sequence"><![CDATA[// When modifying src/features/task_board/task_list.tsx:
// INCORRECT PROCESS:
// 1. Skip checking package specifications
// 2. Check only task_list.specs.md
// 3. Modify task_list.tsx immediately]]></incorrect-example>
        </example>
      </examples>
    </requirement>
    <non-negotiable priority="critical">
      <description>ALWAYS RESPECT THE SPECIFICATIONS. Implement code based on the specifications. Follow EXACTLY the requirements from specifications. Implement ALL requirements that specifications require, PRECISELY.</description>
      <examples>
        <example title="Specification Compliance">
          <correct-example title="Precise implementation of specification" conditions="Implementing a feature" expected-result="Code matches specification exactly" correctness-criteria="Implements all requirements precisely"><![CDATA[// Specification Requirement:
// "Task cards must display a colored border based on priority:
// - High: red border
// - Medium: yellow border
// - Low: green border"

// CORRECT IMPLEMENTATION:
const TaskCard: React.FC<TaskCardProps> = ({ task }) => {
  const borderColor = {
    high: 'border-red-500',
    medium: 'border-yellow-500',
    low: 'border-green-500'
  }[task.priority];

  return (
    <div className={`border-2 ${borderColor} p-4 rounded`}>
      <h3>{task.title}</h3>
      {/* Rest of implementation */}
    </div>
  );
};]]></correct-example>
          <incorrect-example title="Implementation deviating from specification" conditions="Implementing a feature" expected-result="Code matches specification exactly" incorrectness-criteria="Deviates from specification requirements"><![CDATA[// Specification Requirement:
// "Task cards must display a colored border based on priority:
// - High: red border
// - Medium: yellow border
// - Low: green border"

// INCORRECT IMPLEMENTATION:
const TaskCard: React.FC<TaskCardProps> = ({ task }) => {
  const backgroundColor = {
    high: 'bg-red-100',
    medium: 'bg-yellow-100',
    low: 'bg-green-100'
  }[task.priority];

  return (
    <div className={`${backgroundColor} p-4 rounded`}>
      <h3>{task.title}</h3>
      {/* Rest of implementation */}
    </div>
  );
};]]></incorrect-example>
        </example>
      </examples>
    </non-negotiable>
    <requirement priority="high">
      <description>Each specification must define components with a single responsibility (SOLID Principle: Single Responsibility).</description>
      <examples>
        <example title="Single Responsibility Principle">
          <correct-example title="Component with single responsibility" conditions="Designing a component" expected-result="Focused component with clear responsibility" correctness-criteria="Adheres to Single Responsibility Principle"><![CDATA[// CORRECT SPECIFICATION:
# UserProfile Specification

## Overview
The UserProfile component is responsible for displaying user information.

## Technical Requirements
- Display user name, avatar, and profile details
- Support different display formats (compact/full)
- Handle loading states

## Interfaces
type UserProfileProps = {
  userId: string;
  displayFormat?: 'compact' | 'full';
}

// Note: Authentication logic is handled separately in AuthService]]></correct-example>
          <incorrect-example title="Component with mixed responsibilities" conditions="Designing a component" expected-result="Focused component with clear responsibility" incorrectness-criteria="Violates Single Responsibility Principle"><![CDATA[// INCORRECT SPECIFICATION:
# UserProfile Specification

## Overview
The UserProfile component displays user information and handles authentication.

## Technical Requirements
- Display user name, avatar, and profile details
- Handle user login and authentication
- Manage authentication tokens and session
- Display login form when user is not authenticated

## Interfaces
type UserProfileProps = {
  userId?: string;
  onLogin: (username: string, password: string) => void;
  onLogout: () => void;
}]]></incorrect-example>
        </example>
      </examples>
    </requirement>
  </requirements>
  <references>
    <reference as="dependency" href=".cursor/rules/rules.mdc" reason="Follows standard rule format">Base rule format definition</reference>
    <reference as="dependency" href=".cursor/rules/conventions.mdc" reason="Follows project conventions">Defines fundamental project conventions</reference>
  </references>
</rule>
